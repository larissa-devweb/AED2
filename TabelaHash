#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// tamanho inicial da hash que cresce automaticamente depois
#define TAMANHO_TABELA_INICIO 101
#define BASE_POLINOMIAL 31

// cada posição da hash pode ter 3 estados
typedef enum {
    POSICAO_NUNCA_OCUPADA,
    POSICAO_ATUAL_OCUPADA,
    POSICAO_REMOVIDA
} EstadoPosicao;

// guardar informações de uma palavra
typedef struct {
    char *palavra;         // chave
    char *dadosLigados;    // informações associadas
    EstadoPosicao estado;  // estado da posição
} RegistroPalavra;

// estrutura da tabela hash
typedef struct {
    RegistroPalavra *vetorRegistros;
    int tamanhoTabela;
    int quantidadeOcupada;
} TabelaHash;

// função hash primária — polynomial rolling hash
unsigned int funcaoHashPrimaria(const char *chave, int tamanhoTabela) {
    unsigned long long valorHash = 0;
    unsigned long long potencia = 1;

    for (int i = 0; chave[i] != '\0'; i++) {
        valorHash = (valorHash + (chave[i] * potencia)) % tamanhoTabela;
        potencia = (potencia * BASE_POLINOMIAL) % tamanhoTabela;
    }
    return (unsigned int)valorHash;
}

// função hash secundária — somatório dos códigos ASCII
unsigned int funcaoHashSecundaria(const char *chave, int tamanhoTabela) {
    unsigned int soma = 0;
    for (int i = 0; chave[i] != '\0'; i++) {
        soma += chave[i];
    }
    soma = soma % (tamanhoTabela - 1);
    if (soma == 0)
        return 1;
    else
        return soma;
}

// criar tabela hash
TabelaHash *criarTabelaHash(int tamanho) {
    TabelaHash *novaTabela = (TabelaHash *)malloc(sizeof(TabelaHash));
    novaTabela->tamanhoTabela = tamanho;
    novaTabela->quantidadeOcupada = 0;
    novaTabela->vetorRegistros = (RegistroPalavra *)malloc(tamanho * sizeof(RegistroPalavra));

    for (int i = 0; i < tamanho; i++) {
        novaTabela->vetorRegistros[i].estado = POSICAO_NUNCA_OCUPADA;
        novaTabela->vetorRegistros[i].palavra = NULL;
        novaTabela->vetorRegistros[i].dadosLigados = NULL;
    }
    return novaTabela;
}

// liberar memória da tabela
void liberarTabela(TabelaHash *tabela) {
    for (int i = 0; i < tabela->tamanhoTabela; i++) {
        if (tabela->vetorRegistros[i].estado == POSICAO_ATUAL_OCUPADA) {
            free(tabela->vetorRegistros[i].palavra);
            free(tabela->vetorRegistros[i].dadosLigados);
        }
    }
    free(tabela->vetorRegistros);
    free(tabela);
}

// calcular fator de carga (ocupação)
float calcularFatorCarga(TabelaHash *tabela) {
    return (float)tabela->quantidadeOcupada / tabela->tamanhoTabela;
}

// redimensionar tabela
TabelaHash *redimensionarTabela(TabelaHash *tabela) {
    int novoTamanho = tabela->tamanhoTabela * 2 + 1;
    TabelaHash *novaTabela = criarTabelaHash(novoTamanho);

    for (int i = 0; i < tabela->tamanhoTabela; i++) {
        if (tabela->vetorRegistros[i].estado == POSICAO_ATUAL_OCUPADA) {
            char *palavra = tabela->vetorRegistros[i].palavra;
            char *dados = tabela->vetorRegistros[i].dadosLigados;

            unsigned int indice1 = funcaoHashPrimaria(palavra, novaTabela->tamanhoTabela);
            unsigned int indice2 = funcaoHashSecundaria(palavra, novaTabela->tamanhoTabela);

            int tentativa = 0;
            int posicao;

            while (tentativa < novaTabela->tamanhoTabela) {
                posicao = (indice1 + tentativa * indice2) % novaTabela->tamanhoTabela;

                if (novaTabela->vetorRegistros[posicao].estado == POSICAO_NUNCA_OCUPADA ||
                    novaTabela->vetorRegistros[posicao].estado == POSICAO_REMOVIDA) {
                    break;
                }
                tentativa++;
            }

            novaTabela->vetorRegistros[posicao].palavra = strdup(palavra);
            novaTabela->vetorRegistros[posicao].dadosLigados = strdup(dados);
            novaTabela->vetorRegistros[posicao].estado = POSICAO_ATUAL_OCUPADA;
            novaTabela->quantidadeOcupada++;
        }
    }

    liberarTabela(tabela);
    return novaTabela;
}

// inserir palavra
void inserirPalavraNaTabela(TabelaHash **ponteiroTabela, const char *palavra, const char *dadosLigados) {
    TabelaHash *tabela = *ponteiroTabela;

    if (calcularFatorCarga(tabela) >= 0.7) {
        *ponteiroTabela = redimensionarTabela(tabela);
        tabela = *ponteiroTabela;
    }

    unsigned int indice1 = funcaoHashPrimaria(palavra, tabela->tamanhoTabela);
    unsigned int indice2 = funcaoHashSecundaria(palavra, tabela->tamanhoTabela);

    int tentativa = 0;
    int posicao;

    while (tentativa < tabela->tamanhoTabela) {
        posicao = (indice1 + tentativa * indice2) % tabela->tamanhoTabela;

        if (tabela->vetorRegistros[posicao].estado != POSICAO_ATUAL_OCUPADA) {
            tabela->vetorRegistros[posicao].palavra = strdup(palavra);
            tabela->vetorRegistros[posicao].dadosLigados = strdup(dadosLigados);
            tabela->vetorRegistros[posicao].estado = POSICAO_ATUAL_OCUPADA;
            tabela->quantidadeOcupada++;
            return;
        }

        tentativa++;
    }

    printf("Tabela cheia. Não foi possível inserir a palavra: %s\n", palavra);
}

// buscar palavra
char *buscarPalavraNaTabela(TabelaHash *tabela, const char *palavra) {
    unsigned int indice1 = funcaoHashPrimaria(palavra, tabela->tamanhoTabela);
    unsigned int indice2 = funcaoHashSecundaria(palavra, tabela->tamanhoTabela);
    int tentativa = 0;
    int posicao;

    while (tentativa < tabela->tamanhoTabela) {
        posicao = (indice1 + tentativa * indice2) % tabela->tamanhoTabela;

        if (tabela->vetorRegistros[posicao].estado == POSICAO_NUNCA_OCUPADA) {
            return NULL;
        }

        if (tabela->vetorRegistros[posicao].estado == POSICAO_ATUAL_OCUPADA &&
            strcmp(tabela->vetorRegistros[posicao].palavra, palavra) == 0) {
            return tabela->vetorRegistros[posicao].dadosLigados;
        }

        tentativa++;
    }

    return NULL;
}

// remover palavra
void removerPalavraDaTabela(TabelaHash *tabela, const char *palavra) {
    unsigned int indice1 = funcaoHashPrimaria(palavra, tabela->tamanhoTabela);
    unsigned int indice2 = funcaoHashSecundaria(palavra, tabela->tamanhoTabela);
    int tentativa = 0;
    int posicao;

    while (tentativa < tabela->tamanhoTabela) {
        posicao = (indice1 + tentativa * indice2) % tabela->tamanhoTabela;

        if (tabela->vetorRegistros[posicao].estado == POSICAO_NUNCA_OCUPADA) {
            printf("Palavra não encontrada.\n");
            return;
        }

        if (tabela->vetorRegistros[posicao].estado == POSICAO_ATUAL_OCUPADA &&
            strcmp(tabela->vetorRegistros[posicao].palavra, palavra) == 0) {
            free(tabela->vetorRegistros[posicao].palavra);
            free(tabela->vetorRegistros[posicao].dadosLigados);
            tabela->vetorRegistros[posicao].estado = POSICAO_REMOVIDA;
            tabela->quantidadeOcupada--;
            printf("Palavra removida com sucesso.\n");
            return;
        }

        tentativa++;
    }

    printf("Palavra não encontrada.\n");
}

// ler arquivo e carregar para a tabela
void carregarArquivoOpLexicon(TabelaHash **ponteiroTabela, const char *nomeArquivo) {
    FILE *arquivo = fopen(nomeArquivo, "r");
    if (!arquivo) {
        printf("Erro ao abrir %s\n", nomeArquivo);
        return;
    }

    char linha[1024];
    while (fgets(linha, sizeof(linha), arquivo)) {
        char *palavra = strtok(linha, "\t\n");
        char *resto = strtok(NULL, "\n");
        if (palavra && resto) {
            inserirPalavraNaTabela(ponteiroTabela, palavra, resto);
        }
    }

    fclose(arquivo);
}

// main
int main() {
    TabelaHash *tabelaOpLexicon = criarTabelaHash(TAMANHO_TABELA_INICIO);

    printf("Carregando dados de oplexicon.txt...\n");
    carregarArquivoOpLexicon(&tabelaOpLexicon, "oplexicon.txt");

    printf("Digite uma palavra para buscar (ou 'sair' para encerrar)\n");
    char entrada[100];

    while (1) {
        printf("Palavra: ");
        scanf("%s", entrada);

        if (strcmp(entrada, "sair") == 0)
            break;

        char *resultado = buscarPalavraNaTabela(tabelaOpLexicon, entrada);
        if (resultado) {
            printf("Encontrou: %s\n", resultado);
        } else {
            printf("Não encontrada.\n");
        }
    }

    liberarTabela(tabelaOpLexicon);
    return 0;
}
